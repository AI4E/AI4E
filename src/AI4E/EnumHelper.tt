<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
	var underlyingTypes = new Dictionary<Type, string>
	{
		[typeof(byte)] = "byte",
		[typeof(sbyte)] = "sbyte",
		[typeof(ushort)] = "ushort",
		[typeof(short)] = "short",
		[typeof(uint)] = "uint",
		[typeof(int)] = "int",
		[typeof(ulong)] = "ulong",
		[typeof(long)] = "long"
	};
#>
/*
 * This file is auto-generated and should not be modified directly.
 */

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Linq;
using AI4E.Utils;
using static System.Diagnostics.Debug;

namespace AI4E
{
	[GeneratedCodeAttribute("", "")]
    public static partial class EnumHelper
    {
        private static partial class EnumType<TEnum>
            where TEnum : struct, Enum
        {
            private static Func<TEnum, bool> GetFlagEvaluator()
            {
                var enumType = typeof(TEnum);
                Assert(enumType != null);
                Assert(enumType.IsEnum);

                var underlyingType = Enum.GetUnderlyingType(enumType);

<#
bool first = true;
foreach(var underlyingType in underlyingTypes.Keys)
{
	if(!first) 
	{ 
#>
			    else if <# 
	} 
	else
	{
#>
			    if <#
	}
#>(underlyingType == typeof(<#= underlyingTypes[underlyingType] #>))
                {
                    var values = (TEnum[])Enum.GetValues(enumType);
                    var comparand = values.Select(p => CastTo<<#= underlyingTypes[underlyingType] #>>.From(p)).Aggregate(seed: (<#= underlyingTypes[underlyingType] #>)0, (e, c) => (<#= underlyingTypes[underlyingType] #>)(e | c));

                    return value => ((CastTo<<#= underlyingTypes[underlyingType] #>>.From(value)) & ~comparand) == 0;
                }
<#
	first = false;
}
#>
                else
                {
                    throw new InvalidOperationException("Only enums with primitive numeric underlying types are supported.");
                }
            }

            private static Func<TEnum, TEnum, bool> GetHasFlagEvaluator()
            {
                var enumType = typeof(TEnum);
                Assert(enumType != null);
                Assert(enumType.IsEnum);

                var underlyingType = Enum.GetUnderlyingType(enumType);

<#
foreach(var underlyingType in underlyingTypes.Keys)
{
#>
                if (underlyingType == typeof(<#= underlyingTypes[underlyingType] #>))
                {
                    return (value, flag) => (CastTo<<#= underlyingTypes[underlyingType] #>>.From(value) & CastTo<<#= underlyingTypes[underlyingType] #>>.From(flag)) != 0;
                }

<#
}
#>
                throw new InvalidOperationException("Only enums with primitive numeric underlying types are supported.");
            }

            private static Func<TEnum, bool> GetEnumValueEvaluator()
            {
                var enumType = typeof(TEnum);
                Assert(enumType != null);
                Assert(enumType.IsEnum);

                var underlyingType = Enum.GetUnderlyingType(enumType);
<#
foreach(var underlyingType in underlyingTypes.Keys)
{
#>

			    if (underlyingType == typeof(<#= underlyingTypes[underlyingType] #>))
                {
                    var values = new HashSet<<#= underlyingTypes[underlyingType] #>>(((TEnum[])Enum.GetValues(enumType)).Select(p => CastTo<<#= underlyingTypes[underlyingType] #>>.From(p)));

                    if (values.Count == 0)
                    {
                        return _ => false;
                    }

                    if (values.Count == 1)
                    {
				        // We evaluate this here, in order that the hash-set is not captured by the lambda but only the single value.
				        var singleValue = values.First();
                        return value => singleValue == CastTo<<#= underlyingTypes[underlyingType] #>>.From(value);
                    }

                    var min = values.Min();
                    var max = values.Max();

                    Assert(min < max);

                    for (var i = (<#= underlyingTypes[underlyingType] #>)(min + 1); i < max; i++)
                    {
                        if (!values.Contains(i))
                        {
                            return value => values.Contains(CastTo<<#= underlyingTypes[underlyingType] #>>.From(value));
                        }
                    }

                    return value =>
                    {
                        var v = CastTo<<#= underlyingTypes[underlyingType] #>>.From(value);
                        return v >= min && v <= max;
                    };
                }
<#
}
#>

                throw new InvalidOperationException("Only enums with primitive numeric underlying types are supported.");
            }
        }
    }
}
