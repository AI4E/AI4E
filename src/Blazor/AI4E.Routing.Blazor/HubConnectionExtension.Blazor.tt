<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
	var argumentRange = (min: 1, max: 10);

	string BuildGenericArgumentList(int argumentCount)
	{
		StringBuilder result = new StringBuilder(argumentCount*4);

		for(var i = argumentRange.min; i <= argumentCount; i++)
		{
			if(result.Length != 0)
			{
				result.Append(',');
				result.Append(' ');
			}

			result.Append('T');
			result.Append(i);
		}

		return result.ToString();
	}

	string BuildArgumentList(int argumentCount, string argPrefix = "arg")
	{
		StringBuilder result = new StringBuilder(argumentCount*4);

		for(var i = argumentRange.min; i <= argumentCount; i++)
		{
			if(result.Length != 0)
			{
				result.Append(',');
				result.Append(' ');
			}

			result.Append(argPrefix);
			result.Append(i);
		}

		return result.ToString();
	}
#>
/*
 * This file is auto-generated and should not be modified directly.
 */

using System;
using System.CodeDom.Compiler;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using System.Linq.Expressions;
using AI4E.Internal;
using Blazor.Extensions;
using static System.Diagnostics.Debug;

namespace AI4E.Routing.Blazor
{
	[GeneratedCode("", "")]
	public static partial class HubConnectionExtension
    {
<# for(var argumentCount = argumentRange.min; argumentCount <= argumentRange.max; argumentCount++) {#>
		private static readonly MethodInfo _registerMethod<#=argumentCount#>;
<#}#>

		static HubConnectionExtension()
		{
			var methodDefinitions = typeof(HubConnectionExtension).GetMethods(BindingFlags.Static | BindingFlags.NonPublic)
														          .Where(p=> p.Name == nameof(RegisterMethod) && p.IsGenericMethodDefinition);

<# for(var argumentCount = argumentRange.min; argumentCount <= argumentRange.max; argumentCount++) {#>
			_registerMethod<#=argumentCount#> = methodDefinitions.SingleOrDefault(p=>p.GetGenericArguments().Length == <#=argumentCount#>);
<#}#>

<# for(var argumentCount = argumentRange.min; argumentCount <= argumentRange.max; argumentCount++) {#>
			Assert(_registerMethod<#=argumentCount#> != null);
<#}#>
		}
<# for(var argumentCount = argumentRange.min; argumentCount <= argumentRange.max; argumentCount++) {#>
		private static IDisposable RegisterMethod<<#=BuildGenericArgumentList(argumentCount)#>>(HubConnection hubConnection, object obj, MethodInfo method)
        {
#if DEBUG            
			Assert(hubConnection != null);
            Assert(obj != null);
            Assert(method != null);
            Assert(method.DeclaringType.IsAssignableFrom(obj.GetType()));

			var parameters = method.GetParameters();
			Assert(parameters.Length == <#=argumentCount#>);

<# for(var i = argumentRange.min; i <= argumentCount; i++) {#>
			Assert(parameters[<#=i-1#>].ParameterType == typeof(T<#=i#>));
<#}#>
#endif

			Func<<#=BuildGenericArgumentList(argumentCount)#>, Task> handler;

<# for(var i = argumentRange.min; i <= argumentCount; i++) {#>
			var arg<#=i#> = Expression.Parameter(typeof(T<#=i#>), "arg<#=i#>");
<#}#>
			var objConst = Expression.Constant(obj, typeof(object));
            var methodCall = Expression.Call(Expression.Convert(objConst, method.DeclaringType), method, <#=BuildArgumentList(argumentCount)#>);

            // The method is asynchronous 
            if (method.ReturnType.IsAssignableFrom(typeof(Task)))
            {
                var convertedResult = Expression.Convert(methodCall, typeof(Task));

                handler = Expression.Lambda<Func<<#=BuildGenericArgumentList(argumentCount)#>, Task>>(convertedResult, <#=BuildArgumentList(argumentCount)#>).Compile();
            }
            else // TODO: The method can also be async without returning Task. We already have helpers for this.
            {
                var synchronousHandler = Expression.Lambda<Action<<#=BuildGenericArgumentList(argumentCount)#>>>(methodCall, <#=BuildArgumentList(argumentCount)#>).Compile();

                handler = (<#=BuildArgumentList(argumentCount, "p")#>) =>
                {
                    synchronousHandler(<#=BuildArgumentList(argumentCount, "p")#>);
                    return Task.CompletedTask;
                };
            }

            return hubConnection.On(method.Name, handler);
        }
<#}#>
		private static IDisposable RegisterMethod(HubConnection hubConnection, object obj, MethodInfo method, ParameterInfo[] parameters)
        {
            Assert(hubConnection != null);
            Assert(obj != null);
            Assert(method != null);
            Assert(parameters != null);
            Assert(method.GetParameters().SequenceEqual(parameters));
            Assert(method.DeclaringType.IsAssignableFrom(obj.GetType()));

            var parameterCount = parameters.Length;

			/*
			 * We are using reflection here, which is rather slow. 
			 * This is not intended to be futher optimized, as this is called relativel rarely. 
			 * The hot path in the generic RegisterMethod methods is optimized.
			 */

<# for(var argumentCount = argumentRange.min; argumentCount <= argumentRange.max; argumentCount++) {#>
			<#if(argumentCount != 1) {#>else <#}#>if(parameterCount == <#=argumentCount#>)
			{
				var result = _registerMethod<#=argumentCount#>.MakeGenericMethod(parameters.Select(p=> p.ParameterType).ToArray()).Invoke(obj: null, new [] { hubConnection, obj, method }) as IDisposable;
				Assert(result != null);
				return result;
			}
<#}#>
			else
			{
				throw new NotSupportedException("The blazor signal r client supports stub methods with up to ten arguments only.");
			}
        }
	}	
}